<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Balooga</title>
    <link>https://www.balooga.com/</link>
    <description>Recent content on Balooga</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 05 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.balooga.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Prolog Learnings: The Tower of Hanoi</title>
      <link>https://www.balooga.com/posts/prolog-hanoi/</link>
      <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/prolog-hanoi/</guid>
      <description>Explaining an implementation of the Tower of Hanoi in Prolog.   This particular implementaion of the Tower of Hanoi is taken from Peter Flach’s book &amp;#34;Simply Logical: Intelligent Reasoning by Example&amp;#34;, published in 1994 by Wiley. Also available online[1].
 The Tower of Hanoi[2] is a well known puzzle in computer science where finding a solution seems most suited to a recursive rather than iterative algorithm. Three pegs, left, middle, and right with a set of disks on the left peg are stacked in decreasing size - smallest disk on top.</description>
    </item>
    
    <item>
      <title>The Software Crisis: Quotes</title>
      <link>https://www.balooga.com/posts/software-crisis/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/software-crisis/</guid>
      <description>Luke Crook &amp;lt;luke@balooga.com&amp;gt; v1.0, 2021-01-04 :sectanchors: :sectlinks: :icons: font :data-uri: :source-highlighter: rouge :rouge-style: github :page-liquid: :page-layout: false # post # info page default none :page-category: prolog :page-tags: [software crisis ohnos]
 What’s the point in spending the time to learn a 50-year old language anyway?
  As we approach the fiftieth anniversary of the first programmable computer,the twenty-fifth anniversary of the ‘software crisis’ is already long past, that expression first having been used at an international conference in 1968.</description>
    </item>
    
    <item>
      <title>Prolog Learnings: Recursion, Unification and Backtracking</title>
      <link>https://www.balooga.com/posts/prolog-rub/</link>
      <pubDate>Thu, 24 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/prolog-rub/</guid>
      <description>Unification makes Prolog the Tenet of programming languages.   list_length/2 counts the number of elements in a list, where the first argument is a list, and the second argument is the number of elements in the list.
     It is good Prolog practice to try and encode the intent, order and type of arguments in the functor name. So &amp;#34;list_length&amp;#34; defines what the predicate does and that the first argument should be a list and the second the length of the list.</description>
    </item>
    
    <item>
      <title>Prolog Learnings: Predicates and Association of Arguments</title>
      <link>https://www.balooga.com/posts/prolog-predicates/</link>
      <pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/prolog-predicates/</guid>
      <description>Functions (or procedures) in Prolog are called &amp;#34;predicates&amp;#34;, but unlike functions in other languages that can only evaluate inputs to create an output, predicates do not have defined inputs and outputs. In idiomatic Prolog, a predicate is a function that works both ways.     reverse/2 Similar to a function, the predicate reverse/2 can be defined to accept a list of &amp;#39;n&amp;#39; elements and return a new list containing these elements reversed; reverse(List1, List2).</description>
    </item>
    
    <item>
      <title>Prolog Learnings: FizzBuzz</title>
      <link>https://www.balooga.com/posts/prolog-fizzbuzz/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/prolog-fizzbuzz/</guid>
      <description>Elixir builds on Erlang and the first versions of Erlang were implemented in Prolog, so it makes sense that Prolog and Elixir share a number of similarities. For example, Elixir and Prolog support pattern matching with function arguments, but;
   Elixir evaluates arguments prior to performing pattern matching, while
  Prolog does not perform argument evaluation, pattern matching is performed on the shape of whatever is passed as the argument.</description>
    </item>
    
    <item>
      <title>Prolog Learnings: Unification</title>
      <link>https://www.balooga.com/posts/prolog-learn/</link>
      <pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/prolog-learn/</guid>
      <description>The concept of Unification is an underpinning of Prolog. Most languages assign values to variables. For example, the statement int x = 0; causes the value zero to be assigned to x, resulting in x having a value of zero. But a statement like int 0 = x; is a syntax error.
 Prolog performs &amp;#34;Unification&amp;#34; which superficially resembles assignment but is more powerful. Prolog attempts to evaluate the clause below to &amp;#34;true&amp;#34; by &amp;#34;Unifying&amp;#34; (make the same) the term on the left of the = with the term on the right, thus assigning 0 to X.</description>
    </item>
    
    <item>
      <title>Microservice Logging, Monitoring and Alerting Food Fight</title>
      <link>https://www.balooga.com/posts/free-for-all/</link>
      <pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/free-for-all/</guid>
      <description>A subset of folks who advocate for microservices also consider affording each team the freedom to choose their software stack a good thing.
 What then if each team also had the freedom to choose their own logging, monitoring, and alerting stack? Services are monitored using a hodgepodge of Splunk, Moogsoft, Kibana, New Relic, Graphana, and Jira, as well as a collection of homegrown tools. And that’s just within engineering. Ops have their own alerting and ticketing systems, while product rely on handcrafted reports periodically pulled from various sources upon request, manually compiled into Excel or Powerpoint, and then uploaded into Confluence.</description>
    </item>
    
    <item>
      <title>Installing Fedora 32 on a mid-2009 Macbook Pro - Part Three, Applications</title>
      <link>https://www.balooga.com/posts/fedora-on-macbook-part-three/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/fedora-on-macbook-part-three/</guid>
      <description>A series of posts documenting the installation of Fedora 32 onto a mid-2009 15&amp;#34; Macbook Pro. In three parts; Part One describes the initial installation of Fedora and necessary updates to detect the internal WiFi hardware, Part Two describes configuring the window manager i3wm, and Part Three details the installation of the applications that I use daily. As is usual with Linux installations, forewarned is forearmed. Prepare for the lack of internal WiFi capability in the base Fedora install.</description>
    </item>
    
    <item>
      <title>Installing Fedora 32 on a mid-2009 Macbook Pro - Part Two, i3wm</title>
      <link>https://www.balooga.com/posts/fedora-on-macbook-part-two/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/fedora-on-macbook-part-two/</guid>
      <description>A series of posts documenting the installation of Fedora 32 onto a mid-2009 15&amp;#34; Macbook Pro. In three parts; Part One describes the initial installation of Fedora and necessary updates to detect the internal WiFi hardware, Part Two describes configuring the window manager i3wm, and Part Three details the installation of the applications that I use daily. As is usual with Linux installations, forewarned is forearmed. Prepare for the lack of internal WiFi capability in the base Fedora install.</description>
    </item>
    
    <item>
      <title>Installing Fedora 32 on a mid-2009 Macbook Pro - Part One, WiFi</title>
      <link>https://www.balooga.com/posts/fedora-on-macbook-part-one/</link>
      <pubDate>Sat, 29 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/fedora-on-macbook-part-one/</guid>
      <description>A series of posts documenting the installation of Fedora 32 onto a mid-2009 15&amp;#34; Macbook Pro. In three parts; Part One describes the initial installation of Fedora and necessary updates to detect the internal WiFi hardware, Part Two describes configuring the window manager i3wm, and Part Three details the installation of the applications that I use daily. As is usual with Linux installations, forewarned is forearmed. Prepare for the lack of internal WiFi capability in the base Fedora install.</description>
    </item>
    
    <item>
      <title>Future Legacy Applications</title>
      <link>https://www.balooga.com/posts/code-for-the-future/</link>
      <pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/code-for-the-future/</guid>
      <description>Applications become &amp;#34;legacy&amp;#34; when;
   The target platform is deprecated and cannot be recreated, necessitating a rewrite,
  The framework it is built on becomes passe and critical security fixes and new features are added only to a new non-backwards compatible version of the framework, necessitating a rewrite,
  The 3’rd party services the application depends on are deprecated or turned off, necessitating a rewrite,
  The APIs the application uses are forcibly made obsolete in current releases of the OS (recent versions of iOS or OSX, for example.</description>
    </item>
    
    <item>
      <title>When Does New Code Become Legacy Code?</title>
      <link>https://www.balooga.com/posts/legacy-code/</link>
      <pubDate>Tue, 28 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/legacy-code/</guid>
      <description>Legacy code is code without tests   At what point does code become legacy? And what is good code? Answering the second question in a way that suits the rest of this blog post; Good code is code that does not require change, code that performs within spec and has no need of patching or updating even if years, perhaps decades, old.
 Is legacy code just old code?</description>
    </item>
    
    <item>
      <title>Loops in Elixir</title>
      <link>https://www.balooga.com/posts/loops-in-elixir/</link>
      <pubDate>Sat, 11 Jul 2020 09:11:58 -0700</pubDate>
      
      <guid>https://www.balooga.com/posts/loops-in-elixir/</guid>
      <description>Introduction In the following post we will look at a few ways to interate over the first one hundred integers (0 through 99) in Elixir calling FizzBuzz on each.
 Elixir lacks the familiar for, while, until language control-flow constructs that exist in other languages, instead encouraging use of the enumeration capabilities available in the collection modules within the Elixir standard library.
 The core requirements of a FizzBuzz, when passed an integer as a parameter, is to;</description>
    </item>
    
    <item>
      <title>Logging is not the same as Alerting</title>
      <link>https://www.balooga.com/posts/logs-vs-alerting/</link>
      <pubDate>Sat, 10 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/logs-vs-alerting/</guid>
      <description>You&amp;rsquo;re developing the &amp;ldquo;Next Great Service X&amp;rdquo; and are knee deep in the logic managing reads and writes to a data store. Following good engineering practices, you log each read and write operation and cover the nominal use cases. But DevOps need to be notified when access to the data store is lost in production. Is &amp;ldquo;Service X&amp;rdquo;, in addition to logging the error, also responsible for raising an &amp;ldquo;Alert&amp;rdquo; with the Operations or DevOps team?</description>
    </item>
    
    <item>
      <title>Efficiency of the MPEG-2 (H.262), MPEG-4 Part 2 and H.264 codecs</title>
      <link>https://www.balooga.com/posts/h264-codec/</link>
      <pubDate>Sun, 07 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/h264-codec/</guid>
      <description>The following post is quite dated and reflects a 2001 era worflow using ancient technology. These are the hoops we had to jump through.       Introduction Around 2001, I conducted a technology review comparing the coding efficiency of the MPEG-2, MPEG-4 Part 2 and H.264 (MPEG-4 Part 10) codecs in order to pick an effective and efficient compression algorithm to be used in a new satellite directv-to-home DBS system.</description>
    </item>
    
    <item>
      <title>Corman Lisp FFI Howto</title>
      <link>https://www.balooga.com/posts/corman-lisp-ffi/</link>
      <pubDate>Thu, 11 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/corman-lisp-ffi/</guid>
      <description>This post demonstrates the use of the Corman Common Lisp (CCL) FFI.[1] with the SDL[2] library. This post is not a general SDL tutorial, nor should it be considered a primer for learning Common Lisp. NOTE: SDL version 1.2.x is described. SDL APIs described herein have changed in SDL version 2.x.     Introduction This document will describe how Lisp code interfaces with Microsoft Windows Dynamic Link Libraries (DLL’s) using the Corman Common Lisp FFI.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.balooga.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/about/</guid>
      <description>About Luke Crook</description>
    </item>
    
  </channel>
</rss>
