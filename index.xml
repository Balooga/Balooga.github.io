<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Balooga</title>
    <link>https://www.balooga.com/</link>
    <description>Recent content on Balooga</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 10 Dec 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.balooga.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Prolog Learnings: FizzBuzz</title>
      <link>https://www.balooga.com/posts/prolog-fizzbuzz/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/prolog-fizzbuzz/</guid>
      <description>Elixir builds on Erlang, and the first versions of Erlang were implemented in Prolog, so it shouldn&amp;#8217;t have come as such as surprise to me that Prolog and Elixier share a number of similarities. For example, Elixir and Prolog support pattern matching of function arguments, but;
   Elixir performs pattern matching on an argument following any evaluation.
  Prolog does not perform argument evaluation, pattern matching is performed on the shape of whatever is passed as the argument.</description>
    </item>
    
    <item>
      <title>Prolog Learnings: Unification</title>
      <link>https://www.balooga.com/posts/prolog-learn/</link>
      <pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/prolog-learn/</guid>
      <description>Every language I&amp;#8217;ve used up to now assigns values to variables. For example;
 1 int x = 0;    The statement above causes zero to be assigned to x, resulting in x having the value of zero. Prolog uses &#34;Unification&#34; which on the surface resembles assignment but is more powerful.
 1 2 ?- X = 0. X = 0    The &#39;clause&#39; above (Prolog uses the terms clauses, predicates and rules) results in X having the value of zero through a process called Unification (variables in Prolog must start with an uppercase letter.</description>
    </item>
    
    <item>
      <title>Microservice Logging, Monitoring and Alerting Food Fight</title>
      <link>https://www.balooga.com/posts/free-for-all/</link>
      <pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/free-for-all/</guid>
      <description>A subset of folks who advocate for microservices also consider affording each team the freedom to choose their software stack a good thing.
 What then if each team also had the freedom to choose their own logging, monitoring, and alerting stack? Services are monitored using a hodgepodge of Splunk, Moogsoft, Kibana, New Relic, Graphana, and Jira, as well as a collection of homegrown tools. And that&amp;#8217;s just within engineering. Ops have their own alerting and ticketing systems, while product rely on handcrafted reports periodically pulled from various sources upon request, manually compiled into Excel or Powerpoint, and then uploaded into Confluence.</description>
    </item>
    
    <item>
      <title>Installing Fedora 32 on a mid-2009 Macbook Pro - Part Two, i3wm</title>
      <link>https://www.balooga.com/posts/fedora-on-macbook-part-two/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/fedora-on-macbook-part-two/</guid>
      <description>A series of posts documenting the installation of Fedora 32 onto a mid-2009 15&#34; Macbook Pro. In three parts; Part One describes the initial installation of Fedora and necessary updates to detect the internal WiFi hardware, Part Two describes configuring the window manager i3wm, and Part Three details the installation of the applications that I use daily. As is usual with Linux installations, forewarned is forearmed. Prepare for the lack of internal WiFi capability in the base Fedora install.</description>
    </item>
    
    <item>
      <title>Installing Fedora 32 on a mid-2009 Macbook Pro - Part One, WiFi</title>
      <link>https://www.balooga.com/posts/fedora-on-macbook-part-one/</link>
      <pubDate>Sat, 29 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/fedora-on-macbook-part-one/</guid>
      <description>A series of posts documenting the installation of Fedora 32 onto a mid-2009 15&#34; Macbook Pro. In three parts; Part One describes the initial installation of Fedora and necessary updates to detect the internal WiFi hardware, Part Two describes configuring the window manager i3wm, and Part Three details the installation of the applications that I use daily. As is usual with Linux installations, forewarned is forearmed. Prepare for the lack of internal WiFi capability in the base Fedora install.</description>
    </item>
    
    <item>
      <title>Future Legacy Applications</title>
      <link>https://www.balooga.com/posts/code-for-the-future/</link>
      <pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/code-for-the-future/</guid>
      <description>Applications become &#34;legacy&#34; when;
   The target platform is deprecated and cannot be recreated, necessitating a rewrite,
  The framework it is built on becomes passe and critical security fixes and new features are added only to a new non-backwards compatible version of the framework, necessitating a rewrite,
  The 3&amp;#8217;rd party services the application depends on are deprecated or turned off, necessitating a rewrite,
  The APIs the application uses are forcibly made obsolete in current releases of the OS (recent versions of iOS or OSX, for example.</description>
    </item>
    
    <item>
      <title>When Does New Code Become Legacy Code?</title>
      <link>https://www.balooga.com/posts/legacy-code/</link>
      <pubDate>Tue, 28 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/legacy-code/</guid>
      <description>Legacy code is code without tests   At what point does code become legacy? And what is good code? Answering the second question in a way that suits the rest of this blog post; Good code is code that does not require change, code that performs within spec and has no need of patching or updating even if years, perhaps decades, old.
 Is legacy code just old code?</description>
    </item>
    
    <item>
      <title>Loops in Elixir</title>
      <link>https://www.balooga.com/posts/loops-in-elixir/</link>
      <pubDate>Sat, 11 Jul 2020 09:11:58 -0700</pubDate>
      
      <guid>https://www.balooga.com/posts/loops-in-elixir/</guid>
      <description>Introduction In the following post we will look at a few ways to interate over the first one hundred integers (0 through 99) in Elixir calling FizzBuzz on each.
 Elixir lacks the familiar for, while, until language control-flow constructs that exist in other languages, instead encouraging use of the enumeration capabilities available in the collection modules within the Elixir standard library.
 The core requirements of a FizzBuzz, when passed an integer as a parameter, is to;</description>
    </item>
    
    <item>
      <title>Logging is not the same as Alerting</title>
      <link>https://www.balooga.com/posts/logs-vs-alerting/</link>
      <pubDate>Sat, 10 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/logs-vs-alerting/</guid>
      <description>You&amp;rsquo;re developing the &amp;ldquo;Next Great Service X&amp;rdquo; and are knee deep in the logic managing reads and writes to a data store. Following good engineering practices, you log each read and write operation and cover the nominal use cases. But DevOps need to be notified when access to the data store is lost in production. Is &amp;ldquo;Service X&amp;rdquo;, in addition to logging the error, also responsible for raising an &amp;ldquo;Alert&amp;rdquo; with the Operations or DevOps team?</description>
    </item>
    
    <item>
      <title>Efficiency of the MPEG-2 (H.262), MPEG-4 Part 2 and H.264 codecs</title>
      <link>https://www.balooga.com/posts/h264-codec/</link>
      <pubDate>Sun, 07 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/h264-codec/</guid>
      <description>The following post is quite dated and reflects a 2001 era worflow using ancient technology. These are the hoops we had to jump through.       Introduction Around 2001, I conducted a technology review comparing the coding efficiency of the MPEG-2, MPEG-4 Part 2 and H.264 (MPEG-4 Part 10) codecs in order to pick an effective and efficient compression algorithm to be used in a new satellite directv-to-home DBS system.</description>
    </item>
    
    <item>
      <title>Corman Lisp FFI Howto</title>
      <link>https://www.balooga.com/posts/corman-lisp-ffi/</link>
      <pubDate>Thu, 11 Dec 2003 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/corman-lisp-ffi/</guid>
      <description>This post demonstrates the use of the Corman Common Lisp (CCL) FFI.[1] with the SDL[2] library. This post is not a general SDL tutorial, nor should it be considered a primer for learning Common Lisp. NOTE: SDL version 1.2.x is described. SDL APIs described herein have changed in SDL version 2.x.     Introduction This document will describe how Lisp code interfaces with Microsoft Windows Dynamic Link Libraries (DLLâ€™s) using the Corman Common Lisp FFI.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.balooga.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/about/</guid>
      <description>About Luke Crook</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.balooga.com/posts/elixir-learn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.balooga.com/posts/elixir-learn/</guid>
      <description>Digit groups for large integers Elixir supports splitting long integers into digit groups separated by an _. Seems kind of weird, but this syntax is also supported by Prolog.
 Digit Groups 1_000_000     Function Naming Elixir appends the number of arguments - the arity - in the function definition notation to differentiate between functions of the same name. For example, cd/0 and cd/. The first function takes no arguments, and the second takes one argument.</description>
    </item>
    
  </channel>
</rss>